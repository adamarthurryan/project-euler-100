use primal::Sieve;
use digits::Digits;

#[test]
fn solves() {
    assert_eq!(solve_1(),233168);
    assert_eq!(solve_2(),4613732);
    assert_eq!(solve_3(),6857);
    assert_eq!(solve_4(),906609);
    assert_eq!(solve_5(),232792560);
}

fn main() {
    println!("Solution #1: {}", solve_1());
    println!("Solution #2: {}", solve_2());
    println!("Solution #3: {}", solve_3());
    println!("Solution #4: {}", solve_4());
    println!("Solution #5: {}", solve_5());
}


/*If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
Find the sum of all the multiples of 3 or 5 below 1000.*/
fn solve_1() -> usize {
    (1..1000).filter(|n| n%3==0 || n%5==0).sum()
}
/*Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.*/
fn solve_2() -> usize {
    FibIterator::new().take_while(|&n| n<=4_000_000).filter(|&n| n%2 == 0).sum()
}

struct FibIterator {
    x0: usize,
    x1: usize
}
impl FibIterator {
    pub fn new() -> Self {
        FibIterator{x0:0, x1:1}
    }
}
impl Iterator for FibIterator {
    type Item = usize;
    fn next(&mut self) -> Option<Self::Item> {
        let val = self.x1;
        let next = self.x0 + self.x1;
        self.x0 = self.x1;
        self.x1 = next;
        Some(val)
    }
}

fn solve_3() -> usize {
    let sieve = Sieve::new(1_000_000);
    let factors = sieve.factor(600851475143).unwrap();
    factors.into_iter().map(|(p, _k)| p).max().unwrap()
}

/*A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 Ã— 99.
Find the largest palindrome made from the product of two 3-digit numbers.*/
fn solve_4() -> usize {
    let mut palindromes: Vec<_> = Vec::new();
    for x in 100..1000 {
        for y in x..1000 {
            if Digits::new(x*y).is_palindrome() {
                palindromes.push(x*y);
            }
        }
    }

    palindromes.into_iter().max().unwrap()
}
/*2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.
What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?*/
fn solve_5() -> usize {
    [16,9,5,7,11,13,17,19].into_iter().product()
}
